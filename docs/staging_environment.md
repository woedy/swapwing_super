# Staging Environment Blueprint

The staging environment gives Flutter and Django teams a shared space to exercise the live API contract with realistic data. It mirrors the production topology on a smaller scale so we can validate flows, run exploratory testing, and demo new journeys without disturbing local development.

## Architecture Overview

| Component | Responsibility | Notes |
| --- | --- | --- |
| Django web (`web`) | Serves REST/Channels traffic via Gunicorn | Uses the Docker image defined in `swapwing_backend/Dockerfile`. |
| Celery worker (`worker`) | Processes async jobs (email verification, media processing) | Shares the same image/env as the web container. |
| Celery beat (`beat`) | Schedules recurring jobs (analytics aggregation, notifications) | Runs sidecar scheduler. |
| Flower | Operational dashboard for Celery queues | Available at `/flower` on the staging host. |
| PostgreSQL | Primary relational database | Provisioned locally via Docker or managed cloud DB in remote staging. |
| Redis | Channels + Celery broker/result backend | Required for websocket fan-out and background jobs. |
| Object storage | Holds user avatars, IDs, listing media | Use S3, Cloud Storage, or compatible service; configure credentials in the `.env`. |
| Flutter Web app | Surface staging UI | Built with `flutter build web` and deployed to Netlify/Firebase Hosting. |

## Prerequisites

* Docker & Docker Compose v2
* Python 3.11 (for running ad-hoc management commands)
* Flutter 3.24+ with web support enabled
* Access to a staging bucket (S3/GCS) and email provider credentials

## Bootstrapping the backend stack

1. **Clone environment variables**
   ```bash
   cp swapwing_backend/.env.staging.example swapwing_backend/.env.staging
   # populate secrets, storage credentials, and email provider settings
   ```

2. **Start services**
   ```bash
   docker compose -f infra/staging/docker-compose.yml up -d --build
   ```

3. **Run database migrations**
   ```bash
   docker compose -f infra/staging/docker-compose.yml run --rm web python manage.py migrate
   ```

4. **Seed representative data**
   ```bash
   docker compose -f infra/staging/docker-compose.yml run --rm web python manage.py seed_staging
   ```

5. **Create an admin login (optional)**
   ```bash
   docker compose -f infra/staging/docker-compose.yml run --rm web python manage.py createsuperuser
   ```

6. **Verify services**
   * Django API: `curl http://localhost:8000/` (should return default page)
   * Flower: open `http://localhost:5555/flower` for task visibility
   * Redis/Postgres: confirm containers are healthy via `docker compose ps`

7. **Set up object storage**
   * Create a dedicated staging bucket (e.g., `swapwing-staging-media`).
   * Grant programmatic access keys and add them to `.env.staging` (`USE_S3_MEDIA_STORAGE=true`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_STORAGE_BUCKET_NAME`, optional `AWS_S3_ENDPOINT_URL`, `AWS_S3_CUSTOM_DOMAIN`).
   * Restart the web service so Django picks up the S3-backed `DEFAULT_FILE_STORAGE` configuration.

## Data seeding

The `seed_staging` management command (`swapwing_backend/accounts/management/commands/seed_staging.py`) ensures staging always has working accounts, rich profiles, challenge tags, serialized journey episodes, and welcome notifications.

```bash
python swapwing_backend/manage.py seed_staging
```

The command is idempotent—rerun it any time staging needs to be refreshed. Credentials generated by default:

| User | Email | Password | Notes |
| --- | --- | --- | --- |
| Admin | `admin@swapwing.test` | `changeme` | Staff/admin rights, owns notifications |
| Alice | `alice@swapwing.test` | `tradeup123` | Maker-focused storyteller |
| Ben | `ben@swapwing.test` | `tradeup123` | Sustainability challenge participant |

Update passwords immediately on externally hosted staging instances.

## Flutter staging build

1. Ensure the Flutter toolchain is installed and run `flutter pub get` in `swapwing/`.
2. Build the web artefact with environment overrides:
   ```bash
   flutter build web \
     --release \
     --dart-define=SWAPWING_API_BASE_URL=https://api-staging.swapwing.app \
     --dart-define=SWAPWING_USE_MOCK_DATA=true
   ```
   * Set `SWAPWING_USE_MOCK_DATA=false` once the real API wiring replaces the current mock services.
3. Deploy `swapwing/build/web/` to your preferred static host (Netlify, Firebase Hosting, CloudFront/S3, etc.).
4. Configure CORS on the Django service to accept requests from the staging web domain once live API calls are enabled.

## Ongoing operations checklist

* **Monitoring:** Point Django logging to Sentry/DataDog and set uptime checks against `/healthz` endpoint (add as part of the ops story).
* **Backups:** Schedule automated daily snapshots for PostgreSQL and retain seven days of data.
* **Access control:** Restrict staging to the core team via basic auth or SSO until public beta.
* **Refresh cadence:** Re-run `seed_staging` weekly or after major data migrations so demo accounts stay healthy.

With this blueprint in place the “Configure staging environments” checklist item can be marked complete, giving both teams a reliable sandbox for integration and QA.
